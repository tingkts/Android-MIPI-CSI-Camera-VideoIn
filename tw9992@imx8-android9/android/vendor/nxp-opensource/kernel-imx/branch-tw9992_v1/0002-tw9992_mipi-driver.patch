From 936b9a40fb8a0c44f855057d7dca711128ab11a4 Mon Sep 17 00:00:00 2001
From: tingsung <tingsung@msi.com>
Date: Thu, 16 Jan 2020 17:06:44 +0800
Subject: [PATCH 2/3] tw9992_mipi driver

  This is the initial draft version and is still under development,
  so the feature does not work at this time.
---
 .../boot/dts/freescale/msi-imx8qm-ms5765.dtsi |   61 +-
 arch/arm64/configs/ms5765_android_defconfig   |    3 +-
 drivers/media/platform/imx8/Kconfig           |    5 +
 drivers/media/platform/imx8/Makefile          |    7 +-
 drivers/media/platform/imx8/mxc-isi-cap.c     |   30 +
 drivers/media/platform/imx8/mxc-mipi-csi2.c   |   33 +
 drivers/media/platform/imx8/tw9992_mipi.c     | 1414 +++++++++++++++++
 7 files changed, 1545 insertions(+), 8 deletions(-)
 create mode 100644 drivers/media/platform/imx8/tw9992_mipi.c

diff --git a/arch/arm64/boot/dts/freescale/msi-imx8qm-ms5765.dtsi b/arch/arm64/boot/dts/freescale/msi-imx8qm-ms5765.dtsi
index de3a37ad7bfc..3483ecb341a4 100755
--- a/arch/arm64/boot/dts/freescale/msi-imx8qm-ms5765.dtsi
+++ b/arch/arm64/boot/dts/freescale/msi-imx8qm-ms5765.dtsi
@@ -563,6 +563,19 @@
 			>;
 		};
 
+		pinctrl_digitalio_videoin: digitalio_videoin {
+			fsl,pins = <
+				SC_P_ESAI0_TX4_RX1_LSIO_GPIO2_IO30					0x0600004c		//  VIDEO1_EN		Output		High
+				SC_P_ESAI0_TX5_RX0_LSIO_GPIO2_IO31					0x0600004c		//  VIDEO2_EN		Output		High
+
+				SC_P_SIM0_RST_LSIO_GPIO0_IO01						0x0600004c		//  DIG_TR2			Output		High
+				SC_P_SPI3_SCK_LSIO_GPIO2_IO17						0x0600004c		//  DIG_TR3			Output		High
+
+				SC_P_SIM0_IO_LSIO_GPIO0_IO02						0x0600004c		//  DIG_O2			Output		Low
+				SC_P_GPT0_COMPARE_LSIO_GPIO0_IO16					0x0600004c		//  DIG_O3			Output		Low
+			>;
+		};
+
 		pinctrl_gpio_keys: gpio_keysgrp {
 			fsl,pins = <
 				SC_P_SPI0_SDO_LSIO_GPIO3_IO03						0x0600004c // Power Key
@@ -1465,10 +1478,37 @@
 	clock-frequency = <100000>;
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_mipi_csi1_i2c0>;
-	status = "disabled";
+	status = "okay";
 
-	tw9992_mipi@88 {
-		status = "disabled";
+	tw9992_mipi:tw9992_mipi@44 {
+		compatible = "renesas,tw9992_mipi";
+		reg = <0x44>;
+		pinctrl-names = "default";
+		/* pinctrl-0 = <&pinctrl_mipi_csi1>; */
+		pinctrl-0 = <&pinctrl_mipi_csi1_en_rst>, <&pinctrl_digitalio_videoin>;
+		clocks = <&clk IMX8QM_24MHZ>;
+		clock-names = "csi_mclk";
+		csi_id = <1>;
+		/* pwn-gpios = <&gpio1 31 GPIO_ACTIVE_LOW>; */
+		rst-gpios = <&gpio1 30 GPIO_ACTIVE_LOW>;
+
+		video1en_gpio  = <&gpio2 30 GPIO_ACTIVE_LOW>;
+		digtr2_gpio    = <&gpio0 1 GPIO_ACTIVE_HIGH>;
+		digo2_gpio     = <&gpio0 2 GPIO_ACTIVE_LOW>;
+
+		video2en_gpio  = <&gpio2 31 GPIO_ACTIVE_LOW>;
+		digtr3_gpio    = <&gpio2 17 GPIO_ACTIVE_HIGH>;
+		digo3_gpio     = <&gpio0 16 GPIO_ACTIVE_LOW>;
+
+		mclk = </* 24000000 */27000000>;
+		mclk_source = <0>;
+		mipi_csi;
+		status = "okay";
+		port {
+			tw9992_mipi_ep: endpoint {
+				remote-endpoint = <&mipi_csi1_ep>;
+			};
+		};
 	};
 };
 
@@ -1688,6 +1728,19 @@
 	};
 };
 
+&mipi_csi_1 {
+	/delete-property/virtual-channel;
+	status = "okay";
+
+	port@1 {
+		reg = <1>;
+		mipi_csi1_ep: endpoint {
+			remote-endpoint = <&tw9992_mipi_ep>;
+			data-lanes = <1>;
+		};
+	};
+};
+
 &mlb {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_mlb>;
@@ -1717,7 +1770,7 @@
 };
 
 &isi_4 {
-	status = "disabled";
+	status = "okay";
 };
 
 &isi_5 {
diff --git a/arch/arm64/configs/ms5765_android_defconfig b/arch/arm64/configs/ms5765_android_defconfig
index 598fe9e2e096..524b39ac0dbc 100644
--- a/arch/arm64/configs/ms5765_android_defconfig
+++ b/arch/arm64/configs/ms5765_android_defconfig
@@ -593,6 +593,7 @@ CONFIG_GMSL_MAX9286=y
 CONFIG_VIDEO_MXC_CSI_CAMERA=y
 CONFIG_MXC_MIPI_CSI=y
 CONFIG_MXC_CAMERA_OV5640_MIPI_V3=y
+CONFIG_TW9992_MIPI=y
 CONFIG_V4L_MEM2MEM_DRIVERS=y
 CONFIG_VIDEO_SAMSUNG_S5P_JPEG=m
 CONFIG_VIDEO_SAMSUNG_S5P_MFC=m
@@ -997,4 +998,4 @@ CONFIG_CRYPTO_CRC32_ARM64_CE=m
 CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
 CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
 CONFIG_CRYPTO_CHACHA20_NEON=m
-CONFIG_CRYPTO_AES_ARM64_BS=m
+CONFIG_CRYPTO_AES_ARM64_BS=m
\ No newline at end of file
diff --git a/drivers/media/platform/imx8/Kconfig b/drivers/media/platform/imx8/Kconfig
index bf3a0a8e2850..4e84ee358231 100644
--- a/drivers/media/platform/imx8/Kconfig
+++ b/drivers/media/platform/imx8/Kconfig
@@ -50,6 +50,11 @@ config IMX8_JPEG
 	select VIDEOBUF2_DMA_CONTIG
 	default y
 
+config TW9992_MIPI
+	tristate "TW9992_MIPI driver support"
+	depends on I2C
+	default y
+
 source "drivers/media/platform/imx8/hdmi/Kconfig"
 
 endmenu
diff --git a/drivers/media/platform/imx8/Makefile b/drivers/media/platform/imx8/Makefile
index 097a91b3c639..16de46a9c289 100644
--- a/drivers/media/platform/imx8/Makefile
+++ b/drivers/media/platform/imx8/Makefile
@@ -4,12 +4,13 @@ obj-$(CONFIG_IMX8_CAPTURE_DRIVER) += mxc-capture.o
 obj-$(CONFIG_IMX8_MIPI_CSI2) += mxc-mipi-csi2.o
 obj-$(CONFIG_IMX8_PARALLEL_CSI) += mxc-parallel-csi.o
 obj-$(CONFIG_IMX8_MIPI_CSI2_YAV) += mxc-mipi-csi2_yav.o
-ov5640_camera_v3-objs := ov5640_v3.o
-obj-$(CONFIG_MXC_CAMERA_OV5640_V3) += ov5640_camera_v3.o
+# ov5640_camera_v3-objs := ov5640_v3.o
+# obj-$(CONFIG_MXC_CAMERA_OV5640_V3) += ov5640_camera_v3.o
 obj-$(CONFIG_MXC_CAMERA_OV5640_MIPI_V3) += ov5640_mipi_v3.o
+obj-$(CONFIG_TW9992_MIPI) += tw9992_mipi.o
 max9286_gmsl-objs := max9286.o
 obj-$(CONFIG_GMSL_MAX9286) += max9286_gmsl.o
 obj-$(CONFIG_IMX8_MEDIA_DEVICE) += mxc-media-dev.o
 mxc-jpeg-enc-dec-objs := mxc-jpeg-hw.o mxc-jpeg.o
 obj-$(CONFIG_IMX8_JPEG) += mxc-jpeg-enc-dec.o
-obj-$(CONFIG_IMX8_HDMI_RX) += hdmi/
+obj-$(CONFIG_IMX8_HDMI_RX) += hdmi/
\ No newline at end of file
diff --git a/drivers/media/platform/imx8/mxc-isi-cap.c b/drivers/media/platform/imx8/mxc-isi-cap.c
index 1ef99175096e..4ca499349734 100644
--- a/drivers/media/platform/imx8/mxc-isi-cap.c
+++ b/drivers/media/platform/imx8/mxc-isi-cap.c
@@ -1289,6 +1289,35 @@ static int mxc_isi_cap_g_std(struct file *file, void *priv, v4l2_std_id *a)
 	return ret;
 }
 
+static int mxc_isi_cap_s_std(struct file *file, void *fh, v4l2_std_id norm)
+{
+	struct mxc_isi_dev *mxc_isi = video_drvdata(file);
+	struct v4l2_subdev *sd;
+	struct media_pad *source_pad;
+	int ret;
+
+    dev_dbg(&mxc_isi->pdev->dev, "%s\n", __func__);
+
+	/* Get remote source pad */
+	source_pad = mxc_isi_get_remote_source_pad(mxc_isi);
+	if (source_pad == NULL) {
+		v4l2_err(mxc_isi->v4l2_dev, "%s, No remote pad found!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Get remote source pad subdev */
+	sd = media_entity_to_v4l2_subdev(source_pad->entity);
+	if (sd == NULL) {
+		v4l2_err(mxc_isi->v4l2_dev, "%s, No remote subdev found!\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = v4l2_subdev_call(sd, video, s_std, norm);
+
+	return ret;
+}
+
+
 static int mxc_isi_cap_enum_framesizes(struct file *file, void *priv,
 					 struct v4l2_frmsizeenum *fsize)
 {
@@ -1418,6 +1447,7 @@ static const struct v4l2_ioctl_ops mxc_isi_capture_ioctl_ops = {
 	.vidioc_s_parm			= mxc_isi_cap_s_parm,
 
 	.vidioc_g_std			= mxc_isi_cap_g_std,
+	.vidioc_s_std           = mxc_isi_cap_s_std,
 
 	.vidioc_enum_framesizes = mxc_isi_cap_enum_framesizes,
 	.vidioc_enum_frameintervals = mxc_isi_cap_enum_frameintervals,
diff --git a/drivers/media/platform/imx8/mxc-mipi-csi2.c b/drivers/media/platform/imx8/mxc-mipi-csi2.c
index 4c98c4f1b7eb..8f87b10d23eb 100644
--- a/drivers/media/platform/imx8/mxc-mipi-csi2.c
+++ b/drivers/media/platform/imx8/mxc-mipi-csi2.c
@@ -546,6 +546,38 @@ static int mipi_csi2_g_std(struct v4l2_subdev *sd, v4l2_std_id *a)
 	return 0;
 }
 
+static int mipi_csi2_s_std(struct v4l2_subdev *sd, v4l2_std_id norm)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	struct media_pad *source_pad;
+	struct v4l2_subdev *sen_sd;
+	int ret;
+
+    dev_dbg(&csi2dev->pdev->dev, "%s\n", __func__);
+
+	/* Get remote source pad */
+	source_pad = mxc_csi2_get_remote_sensor_pad(csi2dev);
+	if (source_pad == NULL) {
+		v4l2_err(&csi2dev->v4l2_dev, "%s, No remote pad found!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Get remote source pad subdev */
+	sen_sd = media_entity_to_v4l2_subdev(source_pad->entity);
+	if (sen_sd == NULL) {
+		v4l2_err(&csi2dev->v4l2_dev, "%s, No remote subdev found!\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = v4l2_subdev_call(sen_sd, video, s_std, norm);
+	if (ret < 0 && ret != -ENOIOCTLCMD) {
+		v4l2_err(&csi2dev->v4l2_dev, "%s, set remote std faile!\n", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int mipi_csi2_s_stream(struct v4l2_subdev *sd, int enable)
 {
 	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
@@ -693,6 +725,7 @@ static struct v4l2_subdev_video_ops mipi_csi2_video_ops = {
 	.s_parm = mipi_csi2_s_parm,
 	.g_parm = mipi_csi2_g_parm,
 	.g_std = mipi_csi2_g_std,
+    .s_std = mipi_csi2_s_std,
 	.s_stream = mipi_csi2_s_stream,
 };
 
diff --git a/drivers/media/platform/imx8/tw9992_mipi.c b/drivers/media/platform/imx8/tw9992_mipi.c
new file mode 100644
index 000000000000..0c46252eb467
--- /dev/null
+++ b/drivers/media/platform/imx8/tw9992_mipi.c
@@ -0,0 +1,1414 @@
+/*
+ * Copyright(C) 2016-2017 Renesas Electronics Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @file tw9992_mipi.c
+ *
+ * @brief Renesas TW9992 decoder for mipi-csi2.
+ *
+ * @ingroup TVIN
+ *
+ *
+ * CONFIG_MXC_TVIN_TW9992_MIPI for mipi-csi2.
+ * CONFIG_MXC_TVIN_TW9992_BT656 for bt656 interface.
+ */
+/*
+* Change History
+* ==============
+* 170320 1.2 BrianKang      patch for FS-missing issue.
+* 170315 1.1 BrianKang      Kernel 3.14.52
+* 170303 1.0 BrianKang      Kernel 3.10.53
+*                           remove vidioc_int_tw___ and
+*                           FrameMode.
+*                           fix mipi_power_on
+*                           PAL, toggle.
+* 150914 0.7 BrianKang		Kernel 3.10.53
+* 150303 0.5 BrianKang		Add V4L2_BUF_TYPE_VIDEO_CAPTURE_SLAVE routines.
+* 150224     BrianKang		BugFix at ioctl_querystd. Add ~.
+* 150213     BrianKang		BugFix s_frameformat,g_frameformat
+*				Add V4L2_FIELD_SEQ_TB. and try to remove s_frameforamt.
+* 150202 0.4 BrianKang      Merge Freescale code
+*                           Add ioctl_reset, ioctl_x_vc
+* 150107 0.3 BrianKang      Clean code
+* 141110 0.2 BrianKang      Add S_FIELD, it becoems SYNC_FIELD from 0.5.
+* 140915 0.1 BrianKang      First Release
+* 140910 0.0 BrianKang      Dummy
+*/
+
+
+#define DEBUG
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/of_device.h>
+#include <linux/i2c.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regulator/consumer.h>
+#include <linux/fsl_devices.h>
+#include <linux/mipi_csi2.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/version.h>
+// #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,52)
+//     #include "v4l2-int-device.h"
+// #else
+//     #include <media/v4l2-int-device.h>
+// #endif
+// #include "mxc_v4l2_capture.h"
+
+#include <linux/v4l2-mediabus.h>
+#include <linux/media.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+
+//#define DIG_IO
+
+/* ------------------------------------------------------------------------ */
+/* ---------------               TW9992 Hardware            --------------- */
+/* ------------------------------------------------------------------------ */
+
+/*!
+* tw9992 voltages
+    DIGITAL_CORE        1.8V
+    DIGITAL_MIPI        1.8V
+    DIGITAL_IO          1.8V or 3.3V
+    ANALOG_IO           1.8V
+*/
+/* tw9992 MainBoard */
+#define TW9992_VOLTAGE_ANALOG         3300000
+#define TW9992_VOLTAGE_DIGITAL_CORE   3300000
+#define TW9992_VOLTAGE_DIGITAL_IO     3300000
+
+/*
+ * TW9992 I2C ID.
+ * TW9992 can be 0x78,0x7A,0x88 or 0x8A depend on the GP1/GP0.
+*   ID(7bit)    PIN22:PIN19
+*   88(44)        0:0
+*   8A(45)        0:1
+*   78(3C)        1:0
+*   7A(3D)        1:1 (default)
+*
+    #define TW9992_TW9992_ID        0x44    //8bit:0x88 GP1:0 GP0:0
+    #define TW9992_TW9992_ID        0x45    //8bit:0x8A GP1:0 GP0:1
+    #define TW9992_TW9992_ID        0x3C    //8bit:0x78 GP1:1 GP0:0
+    #define TW9992_TW9992_ID        0x3D    //8bit:0x7A GP1:1 GP0:1  (default)
+*/
+#define TW9992_TW9992_ID        0x3D
+
+/*
+ * tw9992 control register number
+ */
+#define IF_NAME                 "tw9992"
+#define tw9992_IDENT            0x00  /* 0x92 */
+#define tw9992_REVID            0x01  /* 0x00 */
+#define tw9992_STATUS1          0x03
+/*
+[7] VDLOSS  1 = Video not present.
+                (Sync is not detected in number of line periods specified by MISSCNT register)
+[6] HLOCK   1 = Horizontal sync PLL is locked to the incoming video source.
+[5] SLOCK   1 = Sub-carrier PLL is locked to the incoming video source.
+[4] FIELD   1 = Odd field is being decoded.
+[3] VLOCK   1 = Vertical logic is locked to the incoming video source.
+[1] MONO    1 = No color burst signal detected.
+[0] DET50   1 = 50Hz source detected
+        The actual output vertical scanning frequency depends on the current standard invoked.
+*/
+
+#define tw9992_RESET            0x06
+/*[7] SRESET  Soft reset.
+      Write a “1” to reset the device to its default state but all register contents remain unchanged.
+      This bit is self-cleared.
+*/
+
+#define tw9992_IA_BRIGHTNESS_Y      0x10  /* Brightness */
+#define tw9992_IA_CONTRAST_Y        0x11  /* Contrast */
+#define tw9992_IA_SHARPNESS         0x12  /* Sharpness */
+#define tw9992_IA_CONTRAST_CB       0x13  /* Saturation Cb */
+#define tw9992_IA_CONTRAST_CR       0x14  /* Saturation Cr */
+#define tw9992_IA_HUE               0x15  /* Hue */
+
+#define tw9992_DEC_STANDARD         0x1C  /* DEC STD select */
+/*[7] DETSTUS 1 = detection in progress
+  [6:4]   STDNOW  Current standard invoked
+          0 = NTSC(M) 1 = PAL(B,D,G,H,I) 2 = SECAM 3 = NTSC4.43
+          4 = PAL(M)  5 = PAL(CN) 6 = PAL60 7 = N/A
+  [2:0]   STANDARD    Standard selection
+              7 = Auto detection
+*/
+
+#define tw9992_DATA_CONVERSION      0x49
+/*[0] BT656   0:YUV422, 1:RGB565 */
+
+#define tw9992_MIPI                 0x70
+/*[7] PD_MIPI 1=power-down-mipi-module
+  [4] PAL 1=PAL-25 FRAMES/SEC; 0=NTSC-30 FRAMES/SEC
+  [3] PROGRESSIVE 1=PROGRESSIVE; 0=INTERLACED INPUT FORMAT
+  [2:0]   LANE_NO  DATA-LANE-NUMBER, 1-4
+*/
+
+#define tw9992_FRAME_FORMAT         0x71
+/*[5] 0:Field mode 1:Frame mode(default) */
+
+#define tw9992_FS_SPECIAL           0x73
+/*[5] 1:FS packet at special 1st LS location. */
+
+#define tw9992_MIPI_VC              0x7F
+/*[1:0] Virtual Channel */
+
+
+#define TW9992_SENS_PAD_SOURCE	0
+#define TW9992_SENS_PADS_NUM	1
+struct tw9992 {
+	// const struct ov5642_platform_data *platform_data;
+	// struct v4l2_int_device *v4l2_int_device;
+    struct v4l2_subdev subdev;
+    struct v4l2_ctrl_handler ctrl_handler;
+	struct i2c_client *i2c_client;
+	struct v4l2_pix_format pix;
+	struct v4l2_captureparm streamcap;
+    struct media_pad pads[TW9992_SENS_PADS_NUM];
+	bool on;
+
+	/* control settings */
+	int brightness;
+	int hue;
+	int contrast;
+	int saturation;
+	int red;
+	int green;
+	int blue;
+	int ae_mode;
+
+	u32 mclk;
+	u8 mclk_source;
+	struct clk *sensor_clk;
+	int ipu_id;
+	int csi;
+
+	void (*io_init)(void);
+
+    int is_mipi;
+    int lanes;
+    int bclock;
+
+    int input_source;
+    v4l2_std_id std_id;
+};
+
+/*!
+ * Maintains the information on the current state of the sensor.
+ */
+//static struct tw9992 tw9992_data;
+static int rst_gpio;
+
+/*
+    int input_source;       CVBS1:0 CVBS2:2 CVBS3:4 CVBS4:6
+    v4l2_std_id std_id;     V4L2_STD_NTSC,V4L2_STD_PAL,V4L2_STD_ALL, or V4L2_STD_UNKNOWN
+*/
+
+// static int tw9992_initialize_controls(struct tw9992 *sensor);
+static int tw9992_probe(struct i2c_client *adapter,
+				const struct i2c_device_id *device_id);
+static int tw9992_remove(struct i2c_client *client);
+
+static int tw9992_init(struct v4l2_subdev *sd);
+static int tw9992_uninit(struct v4l2_subdev *sd);
+
+static int gpio_reguest(struct device *dev, char *gpio_name, unsigned long flags);
+
+/*!
+ *  tw9992 initialization register structure
+ *  1st value = Register Address
+ *  2nd value = Register Value
+ */
+struct reg_value {
+    u8 reg;
+    u8 value;
+};
+
+/*
+    PowerDown MIPI  R70[7]=1
+    FS_SPECIAL      R73[5]=1
+    STG             R3A[6:4]=7
+    STB             R3A[2:0]=0
+*/
+static struct reg_value tw9992_init_default[] = {
+    {0x02,0x40}, /* YSEL[3:0]=0,YIN0 */
+    {0x04,0x00},{0x05,0x09},
+    {0x06,0x00}, /*R06[7],Softreset */
+    {0x07,0x02},{0x08,0x12},
+    {0x09,0xF0},{0x0A,0x09},{0x0B,0xD1},{0x0C,0xCC},{0x0D,0x00},
+    {0x10,0x00},{0x11,0x64},{0x12,0x11},{0x13,0x80},{0x14,0x80},{0x15,0x00},{0x17,0x80},
+    {0x18,0x44},{0x19,0x06},{0x1A,0x00},{0x1C,0x0F},{0x1D,0x7F},{0x1F,0x00},
+    {0x20,0x50},{0x21,0x22},{0x22,0xF0},{0x23,0xD8},{0x24,0xBC},{0x25,0xB8},{0x26,0x44},{0x27,0x38},
+    {0x28,0x00},{0x29,0x00},{0x2A,0x78},{0x2B,0x44},{0x2C,0x30},{0x2D,0x14},{0x2E,0xA5},{0x2F,0xE0},
+    {0x33,0x05},{0x34,0x1A},{0x35,0x00},{0x36,0x5A},{0x37,0x18},{0x38,0xDD},
+    {0x39,0x00},{0x3A,0x30},{0x3B,0x00},{0x3C,0x00},{0x3D,0x00},{0x3F,0x1A},
+    {0x40,0x80},{0x41,0x00},{0x42,0x00},
+    {0x48,0x02},{0x49,0x00},{0x4A,0x81},{0x4B,0x0A},{0x4C,0x00},{0x4D,0x01},{0x4E,0x01},
+    {0x50,0x00},{0x51,0x00},{0x52,0x00},{0x56,0x00},{0x57,0x00},
+    {0x58,0x00},
+    {0x60,0x00},{0x61,0x00},{0x62,0x00},
+    {0x70,0x81}, /*R70[7]=1:PowerDown,You have to clear!. R70[4]=0,NTSC, 1Lane */
+    {0x71,0xA5}, /*R71[5]=1,FrameMode*/
+    {0x72,0xA0},
+    {0x73,0x20}, /*R73[5]=1, FS_SPECIAL=1. You have to clear later! */
+    {0x74,0xF0},{0x75,0x00},{0x76,0x17},{0x77,0x05},
+    {0x78,0x88},{0x79,0x06},{0x7A,0x28},{0x7B,0x46},{0x7C,0xB3},{0x7D,0x06},{0x7E,0x13},
+    {0x7F,0x10}, /*R7F[1:0]=00,VC0*/
+    {0x80,0x05},{0x81,0xA0},{0x82,0x13},{0x83,0x11},{0x84,0x02},{0x85,0x0E},{0x86,0x08},{0x87,0x37},
+    {0x88,0x00},{0x89,0x00},{0x8A,0x02},{0x8B,0x33},{0x8C,0x22},{0x8D,0x03},{0x8E,0x22},{0x8F,0x01},
+    {0x90,0x00},{0x91,0x0C},{0x92,0x00},{0x93,0x0E},{0x94,0x07},{0x95,0xFF},{0x96,0x1A},
+    {0x9B,0x02},
+    {0xA0,0x00},{0xA1,0x00},{0xA2,0x30},{0xA3,0xC0},{0xA4,0x00},
+    {0xC0,0x06},{0xC1,0x20},{0xC2,0x30},{0xC3,0x00},
+    {0xC8,0x58},{0xCA,0x1E},{0xCB,0x1A},
+    {0xD1,0x0E},{0xD2,0x0C},
+    {0xCF,0x0E},
+    {0xD3,0x0A},{0xD4,0x0E},{0xD0,0x0E}
+};
+struct reg_value tw9992_init_diff_default[] = {
+};
+
+struct reg_value tw9992_Decoder_NTSC[] = {
+    {0x07,0x02},{0x08,0x15},{0x09,0xf0},{0x0a,0x12},{0x0b,0xd0}
+};
+struct reg_value tw9992_Decoder_PAL[] = {
+    {0x07,0x12},{0x08,0x19},{0x09,0x20},{0x0a,0x0f},{0x0b,0xd0}
+};
+
+/*! Read one register from a TW9992 i2c slave device.
+ *
+ *  @param *reg		register in the device we wish to access.
+ *  @return		    -1 if fail.
+ */
+//deprecate
+static inline u8 tw9992_i2c_read_reg(struct i2c_client *client, u8 reg)
+{
+    int ret;
+    u8 val;
+
+    ret = i2c_master_send(client, &reg, 1);
+    if (ret < 0) {
+        dev_dbg(&client->dev, "read reg error: ret = %d\n", ret);
+        return -1;
+    }
+    ret = i2c_master_recv(client, &val, 1);
+    if (ret < 0) {
+        dev_dbg(&client->dev, "read reg error: ret = %d\n", ret);
+        return -1;
+    }
+    return val;
+}
+static inline int ReadTW88(struct i2c_client *client, u8 reg)
+{
+	int val;
+
+	val = i2c_smbus_read_byte_data(client, reg);
+	if (val < 0) {
+		dev_info(&client->dev,
+			"%s:read reg error: reg=%2x\n", __func__, reg);
+		return -1;
+	}
+	return val;
+}
+
+/*! Write one register of a TW8844 i2c slave device.
+ *
+ *  @param *reg		register in the device we wish to access.
+ *  @return		    0 if success, an error code otherwise.
+ */
+//deprecate
+static inline int tw9992_i2c_write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+    int ret;
+
+    u8 reg_val[2];
+    reg_val[0] = reg;
+    reg_val[1] = val;
+    ret = i2c_master_send(client,reg_val,2);
+
+    return ret;
+}
+static int WriteTW88(struct i2c_client *client, u8 reg, u8 val)
+{
+	s32 ret;
+
+	ret = i2c_smbus_write_byte_data(client, reg, val);
+	if (ret < 0) {
+		dev_info(&client->dev,
+			"%s:write reg error:reg=%2x,val=%2x\n", __func__,
+			reg, val);
+		return -1;
+	}
+	return 0;
+}
+
+/*!
+ * write arrary register table
+ */
+static int WriteTW88S(struct i2c_client *client, struct reg_value *config, int size)
+{
+    int i;
+    for(i=0; i < size; i++)
+        WriteTW88(client, config[i].reg, config[i].value);
+    return 0;
+}
+
+/*! List of input video formats supported. The video formats is corresponding
+ * with v4l2 id in video_fmt_t
+ */
+typedef enum {
+    TW9992_NTSC = 0,    /*!< Locked on (M) NTSC video signal. */
+    TW9992_PAL,         /*!< (B, G, H, I, N)PAL video signal. */
+    TW9992_NOT_LOCKED,  /*!< Not locked on a signal. */
+} video_fmt_idx;
+
+/*! Number of video standards supported (including 'not locked' signal). */
+#define tw9992_STD_MAX      (TW9992_PAL + 1)
+
+/*! Video format structure. */
+typedef struct {
+    int v4l2_id;        /*!< Video for linux ID. */
+    char name[16];      /*!< Name (e.g., "NTSC", "PAL", etc.) */
+    u16 raw_width;      /*!< Raw width. (total width) */
+    u16 raw_height;     /*!< Raw height. (total width) */
+    u16 active_width;   /*!< Active width. */
+    u16 active_height;  /*!< Active height. */
+	int frame_rate;		/*!< Frame rate. */
+} video_fmt_t;
+
+/*! Description of video formats supported.
+ *
+ *  PAL:  raw=720x625, active=720x576, 25fps.
+ *  NTSC: raw=720x525, active=720x480, 30fps.
+ */
+static video_fmt_t video_fmts[] = {
+    {   /*! NTSC */
+     .v4l2_id = V4L2_STD_NTSC,
+     .name = "NTSC",
+     .raw_width = 720, .raw_height = 525,
+     .active_width = 720, .active_height = 480,
+   	 .frame_rate = 30,
+     },
+    {   /*! (B, G, H, I, N) PAL */
+     .v4l2_id = V4L2_STD_PAL,
+     .name = "PAL",
+     .raw_width = 720, .raw_height = 625,
+     .active_width = 720, .active_height = 576,
+   	 .frame_rate = 25,
+     },
+    {   /*! Unlocked standard */
+     .v4l2_id = V4L2_STD_ALL,
+     .name = "Unlocked",
+     .raw_width = 720, .raw_height = 525,
+     .active_width = 720,   .active_height = 480,
+   	 .frame_rate = 30,
+     },
+};
+
+/* Standard index of TW9992. */
+//static video_fmt_idx video_idx = TW9992_NOT_LOCKED;
+
+
+/*! @brief This mutex is used to provide mutual exclusion.
+ *
+ *  Create a mutex that can be used to provide mutually exclusive
+ *  read/write access to the globally accessible data structures
+ *  and variables that were defined above.
+ */
+static DEFINE_MUTEX(mutex);
+
+
+
+/***********************************************************************
+ * mode info. only for decoder.
+ ***********************************************************************/
+
+typedef enum {
+    INPUT_CVBS1 = 0,INPUT_YIN1,
+    INPUT_CVBS2,    INPUT_YIN3,
+    INPUT_CVBS3,    INPUT_YIN5,
+    INPUT_CVBS4,    INPUT_YIN7,
+    INPUT_DCVBS1,
+    INPUT_DCVBS2,
+    INPUT_DCVBS3,
+    INPUT_DCVBS4
+} TW9992_INPUT_TYPE;
+
+static struct v4l2_input tw9992_inputs[] = {
+    /* Single-ended input */
+    { .index=0,  .name="CVBS1",
+      .type = V4L2_INPUT_TYPE_CAMERA, .std = V4L2_STD_ALL,
+      .capabilities = V4L2_IN_CAP_STD, .status= V4L2_IN_ST_NO_H_LOCK,},
+    { .index=1,  .name="YIN1",
+      .type = V4L2_INPUT_TYPE_CAMERA, .std = V4L2_STD_ALL,
+      .capabilities = V4L2_IN_CAP_STD, .status= V4L2_IN_ST_NO_H_LOCK,},
+    { .index=2,  .name="CVBS2",
+      .type = V4L2_INPUT_TYPE_CAMERA, .std = V4L2_STD_ALL,
+      .capabilities = V4L2_IN_CAP_STD, .status= V4L2_IN_ST_NO_H_LOCK,},
+    { .index=3,  .name="YIN3",
+      .type = V4L2_INPUT_TYPE_CAMERA, .std = V4L2_STD_ALL,
+      .capabilities = V4L2_IN_CAP_STD, .status= V4L2_IN_ST_NO_H_LOCK,},
+    { .index=4,  .name="CVBS3",
+      .type = V4L2_INPUT_TYPE_CAMERA, .std = V4L2_STD_ALL,
+      .capabilities = V4L2_IN_CAP_STD, .status= V4L2_IN_ST_NO_H_LOCK,},
+    { .index=5,  .name="YIN5",
+      .type = V4L2_INPUT_TYPE_CAMERA, .std = V4L2_STD_ALL,
+      .capabilities = V4L2_IN_CAP_STD, .status= V4L2_IN_ST_NO_H_LOCK,},
+    { .index=6,  .name="CVBS4",
+      .type = V4L2_INPUT_TYPE_CAMERA, .std = V4L2_STD_ALL,
+      .capabilities = V4L2_IN_CAP_STD, .status= V4L2_IN_ST_NO_H_LOCK,},
+    { .index=7,  .name="YIN7",
+      .type = V4L2_INPUT_TYPE_CAMERA, .std = V4L2_STD_ALL,
+      .capabilities = V4L2_IN_CAP_STD, .status= V4L2_IN_ST_NO_H_LOCK,},
+    /* Differential input */
+    { .index=8,  .name="DCVBS1",
+      .type = V4L2_INPUT_TYPE_CAMERA, .std = V4L2_STD_ALL,
+      .capabilities = V4L2_IN_CAP_STD, .status= V4L2_IN_ST_NO_H_LOCK,},
+    { .index=9,  .name="DCVBS2",
+      .type = V4L2_INPUT_TYPE_CAMERA, .std = V4L2_STD_ALL,
+      .capabilities = V4L2_IN_CAP_STD, .status= V4L2_IN_ST_NO_H_LOCK,},
+    { .index=10, .name="DCVBS3",
+      .type = V4L2_INPUT_TYPE_CAMERA, .std = V4L2_STD_ALL,
+      .capabilities = V4L2_IN_CAP_STD, .status= V4L2_IN_ST_NO_H_LOCK,},
+    { .index=11, .name="DCVBS4",
+      .type = V4L2_INPUT_TYPE_CAMERA, .std = V4L2_STD_ALL,
+      .capabilities = V4L2_IN_CAP_STD, .status= V4L2_IN_ST_NO_H_LOCK,},
+};
+#define TW9992_INPUT_MAX 11
+
+static struct tw9992 *to_tw9992(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct tw9992, subdev);
+}
+
+/*!
+ * update sensor data
+ * caller ioctl_querystd, ioctl_g_std.
+ */
+static int tw9992_update_sensor_data(struct tw9992 *sensor, v4l2_std_id *std)
+{
+    int ret = 0;
+
+    if (std==0) {
+        pr_debug("%s#%d: std=%d\n", __func__, __LINE__, std);
+        return -EINVAL;
+    }
+    pr_debug("%s#%d: *std=%Lx\n", __func__, __LINE__, *std);
+
+    sensor->std_id = *std;
+
+    if(*std & V4L2_STD_PAL) {
+        sensor->pix.width = 720;
+        sensor->pix.height = 576; /*BT656:625*/
+        sensor->streamcap.timeperframe.denominator = 25;
+        sensor->pix.sizeimage = 720 * 2 * 576;
+    }
+    else {
+        sensor->pix.width = 720;
+        sensor->pix.height = 480; /*BT656:525*/
+        sensor->streamcap.timeperframe.denominator = 30;
+        sensor->pix.sizeimage = 720 * 2 * 480;
+    }
+    // ret = tw9992_check_csi2_rx_mipi_dphy(100);
+    // if(ret)
+    //     pr_err("%s failed tw9992_check_csi2_rx_mipi_dphy\n",__func__);
+    return ret;
+}
+
+//================================================
+// tw9992 & mipi
+//================================================
+int tw9992_check_stable_decoder(struct tw9992 *sensor)
+{
+    volatile u8 reg;
+    int i;
+
+    /* check VDLOSS & LOCK */
+    i=100;
+    while (--i) {
+        reg = ReadTW88(sensor->i2c_client, 0x03);
+        if ((reg & 0xE8) == 0x68)
+            break;
+        msleep(10);
+    }
+    if(i==0) {
+        /* failed */
+        if(reg & 0x80) {
+            pr_debug("%s detect VDLOSS\n",__func__);
+            tw9992_inputs[sensor->input_source].status |= V4L2_IN_ST_NO_SIGNAL;
+        }
+        else {
+            pr_debug("%s fail LOCK R03=%x\n",__func__, reg);
+            tw9992_inputs[sensor->input_source].status |= V4L2_IN_ST_NO_H_LOCK;
+        }
+        return -EINVAL;
+    }
+
+    pr_debug("%s use %d0ms\n",__func__, 99-i);
+    tw9992_inputs[sensor->input_source].status &= ~V4L2_IN_ST_NO_SIGNAL;
+    tw9992_inputs[sensor->input_source].status &= ~V4L2_IN_ST_NO_H_LOCK;
+
+    return 0;
+}
+
+void tw9992_stop_mipi(struct tw9992 *sensor)
+{
+    pr_debug("%s#%d\n", __func__, __LINE__);
+
+    /* stop MIPI */
+    WriteTW88(sensor->i2c_client, 0x70, ReadTW88(sensor->i2c_client, 0x80) |  0x80);
+
+    /* Set FS_SPECIAL */
+    WriteTW88(sensor->i2c_client, 0x73, ReadTW88(sensor->i2c_client, 0x73) |  0x20);
+}
+
+int tw9992_start_mipi(struct tw9992 *sensor)
+{
+    pr_debug("%s#%d\n", __func__, __LINE__);
+
+    int ret = tw9992_check_stable_decoder(sensor);
+
+    /* start MIPI */
+    WriteTW88(sensor->i2c_client, 0x70, ReadTW88(sensor->i2c_client, 0x70) & ~0x80);
+    /* clear FS_SPECIAL */
+    msleep(20); /*170316 Kevin */
+    WriteTW88(sensor->i2c_client, 0x73, ReadTW88(sensor->i2c_client, 0x73) & ~0x20);
+
+    return ret;
+}
+
+void poweron_regulator(void)
+{
+#if 0
+...
+#endif
+}
+
+void poweroff_regulator(void)
+{
+#if 0
+...
+#endif
+}
+
+static inline void tw9992_reset_gpio(void)
+{
+	gpio_set_value_cansleep(rst_gpio, 0);
+	msleep(2);
+	gpio_set_value_cansleep(rst_gpio, 1);
+	msleep(2);
+}
+
+static u32 pixelformat2mbusformat(u32 pixelformat) {
+    if (pixelformat == V4L2_PIX_FMT_UYVY)
+        return MEDIA_BUS_FMT_UYVY8_1X16;
+    return MEDIA_BUS_FMT_RGB565_1X16;
+}
+
+static u32 mbusformat2pixelformat(u32 mbusformat) {
+    if (mbusformat == MEDIA_BUS_FMT_UYVY8_1X16)
+        return V4L2_PIX_FMT_UYVY;
+    return V4L2_PIX_FMT_RGB565;
+}
+
+static int tw9992_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+{
+    pr_debug("%s#%d: type=%d\n", __func__, __LINE__, a->type);
+
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct tw9992 *sensor = to_tw9992(client);
+    struct v4l2_captureparm *cparm = &a->parm.capture;
+    int ret = 0;
+
+    switch (a->type) {
+    /* This is the only case currently handled. */
+    case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+        memset(a, 0, sizeof(*a));
+        a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        cparm->capability = sensor->streamcap.capability;
+        cparm->timeperframe = sensor->streamcap.timeperframe;
+        cparm->capturemode = sensor->streamcap.capturemode;
+        ret = 0;
+        break;
+
+    /* These are all the possible cases. */
+    case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+    case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+    case V4L2_BUF_TYPE_VBI_CAPTURE:
+    case V4L2_BUF_TYPE_VBI_OUTPUT:
+    case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+    case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+        ret = -EINVAL;
+        break;
+
+    default:
+        pr_debug("ioctl_g_parm:type is unknown %d\n", a->type);
+        ret = -EINVAL;
+        break;
+    }
+
+    return ret;
+}
+
+static int tw9992_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *stream)
+{
+    pr_debug("%s#%d\n", __func__, __LINE__);
+
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct tw9992 *sensor = to_tw9992(client);
+	struct v4l2_fract *timeperframe = &stream->parm.capture.timeperframe;
+	u32 tgt_fps;	/* target frames per secound */
+	int ret = 0;
+
+    if(stream->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+ 	    switch (stream->type) {
+      	/* These are all the possible cases. */
+	    case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	    case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+	    case V4L2_BUF_TYPE_VBI_CAPTURE:
+	    case V4L2_BUF_TYPE_VBI_OUTPUT:
+	    case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+	    case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+		    pr_debug("   type is not " \
+			    "V4L2_BUF_TYPE_VIDEO_CAPTURE but %d\n",
+			    stream->type);
+		    ret = -EINVAL;
+		    break;
+	    default:
+		    pr_debug("   type is unknown - %d\n", stream->type);
+		    ret = -EINVAL;
+		    break;
+	    }
+        return ret;
+    }
+    /* Check that the new frame rate is allowed. */
+	if ((timeperframe->numerator == 0) ||
+	    (timeperframe->denominator == 0)) {
+	    if(sensor->std_id == V4L2_STD_PAL)
+    	    timeperframe->denominator = 25;
+	    else
+    	    timeperframe->denominator = 30;
+        timeperframe->numerator = 1;
+    }
+	tgt_fps = timeperframe->denominator /
+		  timeperframe->numerator;
+
+    /* check raw_data ID */
+    if(stream->parm.raw_data[100]=='9'
+    && stream->parm.raw_data[101]=='9'
+    && stream->parm.raw_data[102]=='9'
+    && stream->parm.raw_data[103]=='2'
+    ) {
+        pr_err("9992 raw_data[]\n");
+        sensor->is_mipi = 1;  /* of course ! */
+        /* what do you want to change ? */
+        /* update chip register !!! */
+    }
+
+    pr_debug("%s fps:%d/%d\n",__func__,
+        stream->parm.capture.timeperframe.denominator,
+        stream->parm.capture.timeperframe.numerator);
+
+    // /*check mipi sensor & status*/
+    // ret = tw9992_check_csi2_rx_mipi_dphy(10);
+    // if(ret)
+    //     pr_err("%s failed tw9992_check_csi2_rx_mipi_dphy\n",__func__);
+
+    return ret;
+}
+
+static int tw9992_g_std(struct v4l2_subdev *sd, v4l2_std_id *std) {
+    pr_debug("%s#%d\n", __func__, __LINE__);
+
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct tw9992 *sensor = to_tw9992(client);
+    u8 tmp;
+    //int idx;
+    int ret;
+
+    *std = V4L2_STD_UNKNOWN;
+    tmp = ReadTW88(sensor->i2c_client, 0x03);
+    if(tmp & 0x80) {  /* VDLOSS */
+        pr_err("%s detect VDLOSS\n",__func__);
+        return -EINVAL;
+    }
+    if((tmp & 0x68) != 0x68) {  /* Lock */
+        pr_err("%s fail Lock. R03=%x\n",__func__,tmp);
+        return -EINVAL;
+    }
+
+    /* Read the tw9992_DEC_STANDARD to detect the video standard */
+    tmp = ReadTW88(sensor->i2c_client, (u8)tw9992_DEC_STANDARD);
+    tmp &= 0x70;
+
+    mutex_lock(&mutex);
+    if (tmp == 0x10 || tmp == 0x20 || tmp == 0x50) {
+        *std = V4L2_STD_PAL;
+    } else if (tmp == 0x00 || tmp == 0x30 || tmp == 0x40 || tmp == 0x60) {
+        *std = V4L2_STD_NTSC;
+    } else {
+        *std = V4L2_STD_ALL;
+        pr_debug("Got invalid video standard!\n");
+    }
+    mutex_unlock(&mutex);
+
+    pr_debug("%s detect std:%Lx\n",__func__,*std);
+
+    ret=0;
+    /* This assumes autodetect which this device uses. */
+    /* mipi returns active, bt656 returns raw(period) */
+    if(sensor->std_id != *std) {
+        /*sensor->std_id = *std;*/
+        if(*std == V4L2_STD_PAL) {
+            pr_err("ioctl_g_std %Lx->%Lx PAL\n", sensor->std_id, *std);
+            tw9992_stop_mipi(sensor);
+            WriteTW88S(sensor->i2c_client, tw9992_Decoder_PAL, ARRAY_SIZE(tw9992_Decoder_PAL));
+            WriteTW88(sensor->i2c_client, 0x70, ReadTW88(sensor->i2c_client, 0x70) |  0x10);
+            ret=tw9992_start_mipi(sensor);
+        }
+        else {
+            pr_err("ioctl_g_std %Lx->%Lx NTSC\n", sensor->std_id, *std);
+            tw9992_stop_mipi(sensor);
+            WriteTW88S(sensor->i2c_client, tw9992_Decoder_NTSC, ARRAY_SIZE(tw9992_Decoder_NTSC));
+            WriteTW88(sensor->i2c_client, 0x70, ReadTW88(sensor->i2c_client, 0x70) & ~0x10);
+            ret=tw9992_start_mipi(sensor);
+        }
+
+        ret=tw9992_update_sensor_data(sensor, std);
+        if(ret)
+            pr_err("%s failed tw9992_update_sensor_data\n",__func__);
+    }
+
+    return ret;
+}
+
+static int tw9992_s_std(struct v4l2_subdev *sd, v4l2_std_id std) {
+    pr_debug("%s#%d: std=%Lx\n", __func__, __LINE__, std);
+    return 0;
+}
+
+static int tw9992_enum_framesizes(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_frame_size_enum *fs)
+{
+    pr_debug("%s#%d: index=%d\n", __func__, __LINE__, fs->index);
+
+    if (fs->index > 2)   /*0:NTSC, 1:PAL, 2:Unlock */
+        return -EINVAL;
+
+	fs->max_width = video_fmts[fs->index].active_width;
+	fs->min_width = fs->max_width;
+
+	fs->max_height = video_fmts[fs->index].active_height;
+	fs->min_height = fs->max_height;
+
+	return 0;
+}
+
+static int tw9992_enum_frameintervals(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_frame_interval_enum *fi)
+{
+    pr_debug("%s#%d: index=%d\n", __func__, __LINE__, fi->index);
+
+    if (fi->index > 2)    /* 0:NTSC, 1:PAL, 2:unlock */
+        return -EINVAL;
+
+	if (fi->width == 0 || fi->height == 0 ||
+	    fi->code == 0) {
+		pr_warn("Please assign pixel format, width and height.\n");
+		return -EINVAL;
+	}    
+
+    fi->interval.numerator = 1;
+    fi->interval.denominator = video_fmts[fi->index].frame_rate;
+
+    return 0;
+}
+
+static int tw9992_enum_code(struct v4l2_subdev *sd,
+			    struct v4l2_subdev_pad_config *cfg,
+			    struct v4l2_subdev_mbus_code_enum *code)
+{
+    pr_debug("%s#%d: code->index=%d\n", __func__, __LINE__, code->index);
+
+    if (code->index > 1)
+        return -EINVAL;
+
+    if (code->index == 1) {
+        code->code = MEDIA_BUS_FMT_RGB565_1X16;
+        //strcpy(fmt->description, "RGBP");
+    } else {
+        code->code = MEDIA_BUS_FMT_UYVY8_1X16;
+        //strcpy(fmt->description, "UYUV");
+    }
+    return 0;
+}
+
+static int tw9992_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct tw9992 *sensor = to_tw9992(client);
+	int ret;
+
+    pr_debug("%s#%d: mbusformat=0x%X, pixelformat=0x%X\n", __func__, __LINE__, mf->code, sensor->pix.pixelformat);
+
+	if (format->pad)
+		return -EINVAL;
+
+	// mf->code = pixelformat2mbusformat(sensor->pix.pixelformat);
+	// mf->colorspace = V4L2_COLORSPACE_JPEG;
+	// mf->width = sensor->pix.width;
+	// mf->height = sensor->pix.height;
+	// mf->field = sensor->pix.filed;
+
+	// try_to_find_resolution(sensor, mf);
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		return 0;
+
+	if (sensor->pix.pixelformat != mbusformat2pixelformat(mf->code)) {
+		//pr_err("%s pixelformat %x->%x\n", __func__, sensor->pix.pixelformat, f->fmt.pix.pixelformat);
+        // mipi_csi2_info = mipi_csi2_get_info();
+        // if(mipi_csi2_info==0) {
+        //     pr_err("%s mipi_csi2_info fail\n",__func__);
+        //     return -1;
+        // }
+		tw9992_stop_mipi(sensor);
+        if (sensor->pix.pixelformat == V4L2_PIX_FMT_UYVY) {
+            // mipi_csi2_set_datatype(mipi_csi2_info, MIPI_DT_YUV422);
+		    WriteTW88(sensor->i2c_client, 0x49, ReadTW88(sensor->i2c_client, 0x49) & ~0x01);
+        } else if (sensor->pix.pixelformat == V4L2_PIX_FMT_RGB565) {
+            // mipi_csi2_set_datatype(mipi_csi2_info, MIPI_DT_RGB565);
+		    WriteTW88(sensor->i2c_client, 0x49, ReadTW88(sensor->i2c_client, 0x49) | 0x01);
+        } else {
+		    pr_err("currently this sensor format can not be supported!\n");
+		}
+		ret = tw9992_start_mipi(sensor);
+    }
+
+	sensor->pix.pixelformat = mbusformat2pixelformat(mf->code);
+	sensor->pix.width = mf->width;
+	sensor->pix.height = mf->height;
+	sensor->pix.field = mf->field;
+
+    // /*check mipi sensor & status*/
+    // ret = tw9992_check_csi2_rx_mipi_dphy(10);
+    // if(ret)
+    //     pr_err("%s failed tw9992_check_csi2_rx_mipi_dphy\n",__func__);
+
+	return ret;
+}
+
+static int tw9992_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct tw9992 *sensor = to_tw9992(client);
+
+    pr_debug("%s#%d\n", __func__, __LINE__);
+
+	if (format->pad)
+		return -EINVAL;
+
+	memset(mf, 0, sizeof(struct v4l2_mbus_framefmt));
+
+	mf->code = pixelformat2mbusformat(sensor->pix.pixelformat);
+	mf->colorspace = V4L2_COLORSPACE_JPEG;
+	mf->width = sensor->pix.width;
+	mf->height = sensor->pix.height;
+	mf->field = sensor->pix.field;
+	//mf->reserved[1] = find_hs_configure(sensor);
+
+	dev_dbg(&client->dev, "%s code=0x%x, w/h=(%d,%d), colorspace=%d, field=%d\n",
+		__func__, mf->code, mf->width, mf->height, mf->colorspace, mf->field);
+
+	return 0;
+}
+
+static int tw9992_s_stream(struct v4l2_subdev *sd, int enable)
+{
+    pr_debug("%s#%d: enable=%d\n", __func__, __LINE__, enable);
+
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct tw9992 *sensor = to_tw9992(client);
+
+	if (enable)
+		tw9992_start_mipi(sensor);
+	else
+		tw9992_stop_mipi(sensor);
+
+	sensor->on = enable;
+	return 0;
+}
+
+static int tw9992_s_power(struct v4l2_subdev *sd, int on)
+{
+    pr_info("%s#%d: on=%d\n", __func__, __LINE__, on);
+
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct tw9992 *sensor = to_tw9992(client);
+
+	// if (on)
+	// 	clk_prepare_enable(sensor->sensor_clk);
+	// else
+	// 	clk_disable_unprepare(sensor->sensor_clk);
+
+	sensor->on = on;
+	return 0;
+}
+
+int tw9992_reset(struct v4l2_subdev *sd, u32 val) {
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct tw9992 *sensor = to_tw9992(client);
+
+    pr_info("%s#%d: val=%d\n", __func__, __LINE__, val);
+
+    u8 tmp;
+
+    tmp = ReadTW88(sensor->i2c_client, 0x06);
+    WriteTW88(sensor->i2c_client, 0x06, tmp | 0x80);
+    return 0;
+}
+
+static int tw9992_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh) {
+    pr_debug("%s#%d\n", __func__, __LINE__);
+    return 0;
+}
+
+static int tw9992_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh) {
+    pr_debug("%s#%d\n", __func__, __LINE__);
+	return 0;
+}
+
+static int tw9992_init(struct v4l2_subdev *sd) {
+    pr_debug("%s#%d\n", __func__, __LINE__);
+
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct tw9992 *sensor = to_tw9992(client);
+    int ret = 0;
+
+    sensor->on = true;
+
+    tw9992_stop_mipi(sensor);
+    WriteTW88S(sensor->i2c_client, tw9992_init_default, ARRAY_SIZE(tw9992_init_default));
+
+    if(sensor->std_id==V4L2_STD_PAL) {
+        pr_debug("Ok!, It was PAL!!!\n");
+        WriteTW88S(sensor->i2c_client, tw9992_Decoder_PAL, ARRAY_SIZE(tw9992_Decoder_PAL));
+        WriteTW88(sensor->i2c_client, 0x70, ReadTW88(sensor->i2c_client, 0x70) |  0x10);
+    }
+    else {
+        WriteTW88S(sensor->i2c_client, tw9992_Decoder_NTSC, ARRAY_SIZE(tw9992_Decoder_NTSC));
+        WriteTW88(sensor->i2c_client, 0x70, ReadTW88(sensor->i2c_client, 0x70) & ~0x10); /*---*/
+    }
+    if(sensor->pix.pixelformat == V4L2_PIX_FMT_RGB565)
+	    WriteTW88(sensor->i2c_client, 0x49, ReadTW88(sensor->i2c_client, 0x49) | 0x01);
+    else /* assume V4L2_PIX_FMT_UYVY */
+        WriteTW88(sensor->i2c_client, 0x49, ReadTW88(sensor->i2c_client, 0x49) & ~0x01);
+
+    // input_source
+    WriteTW88(sensor->i2c_client, 0x02, 0x40 | sensor->input_source); 
+    WriteTW88S(sensor->i2c_client, tw9992_Decoder_NTSC, ARRAY_SIZE(tw9992_Decoder_NTSC));
+
+    ret=tw9992_start_mipi(sensor);
+
+    if(sensor->std_id==V4L2_STD_PAL) {
+        if(sensor->pix.height != 576) {
+            pr_debug("   sensor->pix.height %d->576\n",sensor->pix.height);
+            sensor->pix.width = 720;
+            sensor->pix.height = 576; /*BT656:625*/
+            sensor->streamcap.timeperframe.denominator = 25;
+            sensor->pix.sizeimage = 720 * 2 * 576;
+        }
+    }
+    else {
+        if(sensor->pix.height != 480) {
+            pr_debug("   sensor->pix.height %d->480\n",sensor->pix.height);
+            sensor->pix.width = 720;
+            sensor->pix.height = 480; /*BT656:525*/
+            sensor->streamcap.timeperframe.denominator = 30;
+            sensor->pix.sizeimage = 720 * 2 * 480;
+        }
+    }
+
+    // /* initial mipi dphy */
+    // mipi_csi2_info = mipi_csi2_get_info();
+    // if(mipi_csi2_info == 0) {
+    //     pr_err("Fail to get mipi_csi2_info!\n");
+    //     return -1;
+    // }
+    // if (!mipi_csi2_get_status(mipi_csi2_info))
+    //     mipi_csi2_enable(mipi_csi2_info);
+
+    // if (!mipi_csi2_get_status(mipi_csi2_info)) {
+    //     pr_err("Can not enable mipi csi2 driver!\n");
+    //     return -1;
+    // }
+    // ret = mipi_csi2_set_lanes_by_num(mipi_csi2_info, sensor->lanes);
+    // ret += 1;
+    // pr_debug("mipi_csi2_info lanes:%d ",ret);
+
+
+    // /* Only reset MIPI CSI2 HW at sensor initialize.  */
+	// mipi_csi2_reset(mipi_csi2_info, sensor->bclock / sensor->lanes);
+    // if (sensor->pix.pixelformat == V4L2_PIX_FMT_UYVY)
+    //     mipi_csi2_set_datatype(mipi_csi2_info, MIPI_DT_YUV422);
+    // else if(sensor->pix.pixelformat == V4L2_PIX_FMT_RGB565)
+    //     mipi_csi2_set_datatype(mipi_csi2_info, MIPI_DT_RGB565);
+    // else
+	//     pr_err("currently this sensor format can not be supported!\n");
+
+
+    // /*check mipi sensor & status*/
+    // ret = tw9992_check_csi2_rx_mipi_dphy(100);
+    // if(ret)
+    //     pr_err("%s failed tw9992_check_csi2_rx_mipi_dphy\n",__func__);
+
+    pr_debug("%s#%d ret=%d\n", __func__, __LINE__, ret);
+    return ret;
+}
+
+static int tw9992_uninit(struct v4l2_subdev *sd) {
+    pr_debug("%s#%d\n", __func__, __LINE__);
+
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct tw9992 *sensor = to_tw9992(client);
+
+	// if (sensor->i2c_client != NULL) {
+	// 	mipi_csi2_info = mipi_csi2_get_info();
+
+	// 	/* disable mipi csi2 */
+	// 	if (mipi_csi2_info)
+	// 		if (mipi_csi2_get_status(mipi_csi2_info))
+	// 			mipi_csi2_disable(mipi_csi2_info);
+	// }
+
+    sensor->on = false;
+	return 0;
+}
+
+static int tw9992_link_setup(struct media_entity *entity,
+			   const struct media_pad *local,
+			   const struct media_pad *remote, u32 flags)
+{
+    pr_debug("%s#%d\n", __func__, __LINE__);
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops tw9992_internal_ops = {
+	.open = tw9992_open,
+    .close = tw9992_close,
+};
+
+static struct v4l2_subdev_video_ops tw9992_subdev_video_ops = {
+	.g_parm         = tw9992_g_parm,
+	.s_parm         = tw9992_s_parm,
+	.s_stream       = tw9992_s_stream,
+	.g_std          = tw9992_g_std,
+	.s_std          = tw9992_s_std,
+};
+
+static const struct v4l2_subdev_pad_ops tw9992_subdev_pad_ops = {
+	.enum_frame_size       = tw9992_enum_framesizes,
+	.enum_frame_interval   = tw9992_enum_frameintervals,
+	.enum_mbus_code        = tw9992_enum_code,
+	.set_fmt               = tw9992_set_fmt,
+	.get_fmt               = tw9992_get_fmt,
+};
+
+static struct v4l2_subdev_core_ops tw9992_subdev_core_ops = {
+	.s_power	  = tw9992_s_power,
+    .reset        = tw9992_reset,
+};
+
+static struct v4l2_subdev_ops tw9992_subdev_ops = {
+	.core	= &tw9992_subdev_core_ops,
+	.video	= &tw9992_subdev_video_ops,
+	.pad	= &tw9992_subdev_pad_ops,
+};
+
+static const struct media_entity_operations tw9992_sd_media_ops = {
+	.link_setup = tw9992_link_setup,
+};
+
+/*!
+ * tw9992 I2C probe function
+ *
+ * @param adapter            struct i2c_adapter *
+ * @return  Error code indicating success or failure
+ */
+static int tw9992_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+    struct pinctrl *pinctrl;
+    struct device *dev = &client->dev;
+    struct v4l2_subdev *sd;
+    u8 chip_id, rev_id;
+    int ret;
+    struct tw9992 *sensor;
+
+    pr_debug("%s#%d\n", __func__, __LINE__);
+
+	sensor = devm_kmalloc(dev, sizeof(*sensor), GFP_KERNEL);
+	if (!sensor) {
+        pr_err("%s#%d: devm_kmalloc fail!\n", __func__, __LINE__);
+		return -ENOMEM;
+    }
+	/* Set initial values for the sensor struct. */
+	memset(sensor, 0, sizeof(*sensor));
+
+    /* Check if the adapter supports the needed features */
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+        printk(KERN_ERR "%s#%d fail\n", __func__, __LINE__);
+        return -ENODEV;
+    }
+
+    v4l_info(client, "chip found @ 0x%x (%s)\n",
+        client->addr << 1, client->adapter->name);
+
+	/* tw9992 pinctrl */
+	pinctrl = devm_pinctrl_get_select_default(dev);
+	if (IS_ERR(pinctrl)) {
+		dev_err(dev, "setup pinctrl failed\n");
+		return PTR_ERR(pinctrl);
+	}
+
+	/* request reset pin */
+	rst_gpio = of_get_named_gpio(dev->of_node, "rst-gpios", 0);
+	if (!gpio_is_valid(rst_gpio))
+		dev_warn(dev, "No sensor reset pin available");
+	else {
+		ret = devm_gpio_request_one(dev, rst_gpio,
+				GPIOF_OUT_INIT_HIGH, "tw9992_mipi_reset");
+		if (ret < 0) {
+			dev_warn(dev, "Failed to set reset pin\n");
+			return ret;
+		}
+	}
+
+#ifdef DIG_IO
+    int video1en_gpio = gpio_reguest(dev, "video1en_gpio", GPIOF_OUT_INIT_HIGH);
+    int digtr2_gpio   = gpio_reguest(dev, "digtr2_gpio",   GPIOF_OUT_INIT_HIGH);
+    int digo2_gpio    = gpio_reguest(dev, "digo2_gpio",    GPIOF_OUT_INIT_LOW);
+    int video2en_gpio = gpio_reguest(dev, "video2en_gpio", GPIOF_OUT_INIT_HIGH);
+    int digtr3_gpio   = gpio_reguest(dev, "digtr3_gpio",   GPIOF_OUT_INIT_HIGH);
+    int digo3_gpio    = gpio_reguest(dev, "digo3_gpio",    GPIOF_OUT_INIT_LOW);
+#endif // DIG_IO
+
+    sensor->sensor_clk = devm_clk_get(dev, "csi_mclk");
+    if (IS_ERR(sensor->sensor_clk)) {
+        /* assuming clock enabled by default */
+        sensor->sensor_clk = NULL;
+        dev_err(dev, "clock-frequency missing or invalid\n");
+        return PTR_ERR(sensor->sensor_clk);
+    }
+
+	/* read property from device tree.
+	    clock-names = "csi_mclk";
+        tw9992.mclk = 27000000;
+        tw9992.mclk_source = 0;
+        tw9992.csi_id = 0;
+    */
+    ret = of_property_read_u32(dev->of_node, "mclk", &sensor->mclk);
+    if (ret) {
+        dev_err(dev, "mclk missing or invalid\n");
+        return ret;
+    }
+    ret = of_property_read_u32(dev->of_node, "mclk_source",
+            (u32 *) &(sensor->mclk_source));
+    if (ret) {
+        dev_err(dev, "mclk_source missing or invalid\n");
+        return ret;
+    }
+    ret = of_property_read_u32(dev->of_node, "csi_id", &(sensor->csi));
+    if (ret) {
+        dev_err(dev, "csi id missing or invalid\n");
+        return ret;
+    }
+
+    // tw9992 hw clk, no need sw code settings.
+    // clk_prepare_enable(sensor->sensor_clk);
+
+    sensor->i2c_client = client;
+    sensor->pix.width = 720;
+    sensor->pix.height = 480;
+    sensor->pix.field = V4L2_FIELD_INTERLACED_TB;
+    sensor->pix.pixelformat = V4L2_PIX_FMT_UYVY;
+    sensor->pix.bytesperline = 720 * 2;
+    sensor->pix.sizeimage = 720 * 2 * 480;
+    sensor->pix.priv = 1;  /* NOTE: 1:TV_in, 0:Camera */
+    sensor->streamcap.capturemode = 0; /* for Camera type */
+    sensor->streamcap.timeperframe.denominator = 30;
+    sensor->streamcap.timeperframe.numerator = 1;
+    sensor->streamcap.capability = V4L2_MODE_HIGHQUALITY | V4L2_CAP_TIMEPERFRAME;
+
+    sensor->is_mipi = 1;    /*fixed*/
+    sensor->lanes = 1;      /*fixed*/
+    sensor->bclock = 216;   /*fixed*/
+
+    sensor->on = false; /* _dev_init() will assign true*/
+
+    sensor->std_id = V4L2_STD_UNKNOWN;  /*unlock*/
+    sensor->input_source = 0;           /*CVBS1*/
+
+    /* powerup regulator */
+    poweron_regulator();
+
+    tw9992_reset_gpio();
+
+    /* Chip ID Check */
+    chip_id = ReadTW88(sensor->i2c_client, tw9992_IDENT);
+    if(chip_id != 0x92) {
+        pr_warning("tw9992 not found, chip_id read(0x00) = 0x%02x.\n", chip_id);
+        poweroff_regulator();
+        return 0;
+    }
+    rev_id = ReadTW88(sensor->i2c_client, tw9992_REVID);
+    pr_info("Renesas tw9992 id:%2X rev:%2X is found.\n", chip_id,rev_id);
+
+    sd = &sensor->subdev;
+	v4l2_i2c_subdev_init(sd, client, &tw9992_subdev_ops);
+
+    // ret = tw9992_initialize_controls(sensor);
+    // pr_debug("%s#%d: 0x%X = tw9992_initialize_controls()\n", __func__, __LINE__, ret);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+    //sd->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+    sensor->pads[TW9992_SENS_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+	ret = media_entity_pads_init(&sd->entity, TW9992_SENS_PADS_NUM, sensor->pads);
+	if (ret < 0) {
+        pr_err("%s#%d: media_entity_pads_init fail!\n", __func__, __LINE__);
+		return ret;
+	}
+
+    sd->internal_ops = &tw9992_internal_ops;
+    sd->entity.ops = &tw9992_sd_media_ops;
+
+	ret = v4l2_async_register_subdev(sd);
+	if (ret < 0) {
+		dev_err(&client->dev,
+				"%s--Async register failed, ret=%d\n", __func__, ret);
+		media_entity_cleanup(&sd->entity);
+	}
+
+    tw9992_init(sd);
+
+    printk(KERN_INFO "%s ok\n", __func__);
+
+#ifdef DIG_IO
+    devm_gpio_free(dev, video1en_gpio);
+    devm_gpio_free(dev, digtr2_gpio);
+    devm_gpio_free(dev, digo2_gpio);
+    devm_gpio_free(dev, video2en_gpio);
+    devm_gpio_free(dev, digtr3_gpio);
+    devm_gpio_free(dev, digo3_gpio);
+#endif // DIG_IO
+
+    return ret;
+}
+
+/*!
+ * tw9992 I2C detach function
+ *
+ * @param client            struct i2c_client *
+ * @return  Error code indicating success or failure
+ */
+static int tw9992_remove(struct i2c_client *client)
+{
+    pr_debug("%s#%d\n", __func__, __LINE__);
+
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct tw9992 *sensor = to_tw9992(sd);
+
+    v4l2_ctrl_handler_free(&sensor->ctrl_handler);
+
+    tw9992_uninit(sd);
+
+    /* poweroff_regulator */
+    poweroff_regulator();
+
+    return 0;
+}
+
+static int gpio_reguest(struct device *dev, char *gpio_name, unsigned long flags) {
+	/* request reset pin */
+	int gpio = of_get_named_gpio(dev->of_node, gpio_name, 0);
+	if (!gpio_is_valid(gpio)) {
+		dev_err(dev, "%s#%d No sensor %s pin available\n", __func__, __LINE__, gpio_name);
+	}
+	else {
+		int ret = devm_gpio_request_one(dev, gpio,
+				flags, gpio_name);
+		if (ret < 0) {
+			dev_err(dev, "%s#%d Failed to set %s pin\n", __func__, __LINE__, gpio_name);
+		}
+	}
+    return gpio;
+}
+
+/**
+* for platform device driver
+* ---------------------------
+* NOTE: add TW9992 id, 0x7A(7bit,0x3D) in arch/arm/mach-mx6/board-xxxx.c
+*       and, .type will be "tw9992_mipi".
+*
+* for example
+*   static struct i2c_board_info wand_mipi_csi_i2c_board_info[] __initdata = {
+*       {
+*           I2C_BOARD_INFO("tw9992_mipi", 0x44),
+*           .platform_data = (void *)&wand_mipi_csi2_data,
+*       },
+*   };
+*/
+static const struct i2c_device_id tw9992_i2c_id[] = {
+    {"tw9992_mipi", 0},
+    {},
+};
+MODULE_DEVICE_TABLE(i2c, tw9992_i2c_id);
+
+static struct i2c_driver tw9992_i2c_driver = {
+    .driver = {
+        .owner = THIS_MODULE,
+        .name  = "tw9992_mipi",
+    },
+    .probe  = tw9992_probe,
+    .remove = tw9992_remove,
+    .id_table = tw9992_i2c_id,
+};
+
+module_i2c_driver(tw9992_i2c_driver);
+
+MODULE_AUTHOR("Brian Kang brian.kang.ry@renesas.com");
+MODULE_DESCRIPTION("TW9992 MIPI Decoder driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.2");
+MODULE_ALIAS("CSI");
\ No newline at end of file
-- 
2.21.0

